<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gasless Transaction Manager</title>
    <meta name="description" content="Secure gasless transaction manager for ERC20 tokens">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.7.1/ethers.umd.min.js"></script>
    <style>
        :root {
            --primary-color: #2563eb;
            --primary-hover: #1d4ed8;
            --secondary-color: #10b981;
            --secondary-hover: #059669;
            --danger-color: #ef4444;
            --danger-hover: #dc2626;
            --warning-color: #f59e0b;
            --warning-hover: #d97706;
            --gray-50: #f9fafb;
            --gray-100: #f3f4f6;
            --gray-200: #e5e7eb;
            --gray-300: #d1d5db;
            --gray-400: #9ca3af;
            --gray-500: #6b7280;
            --gray-600: #4b5563;
            --gray-700: #374151;
            --gray-800: #1f2937;
            --gray-900: #111827;
            --success-bg: #dcfce7;
            --success-border: #bbf7d0;
            --success-text: #166534;
            --error-bg: #fef2f2;
            --error-border: #fecaca;
            --error-text: #991b1b;
            --warning-bg: #fffbeb;
            --warning-border: #fed7aa;
            --warning-text: #92400e;
            --info-bg: #eff6ff;
            --info-border: #bfdbfe;
            --info-text: #1e40af;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --border-radius: 8px;
            --transition: all 0.15s ease-in-out;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, var(--gray-50) 0%, var(--gray-100) 100%);
            min-height: 100vh;
            color: var(--gray-900);
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-hover) 100%);
            color: white;
            padding: 2rem;
            border-radius: var(--border-radius);
            margin-bottom: 2rem;
            text-align: center;
            box-shadow: var(--shadow-md);
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .section {
            background: white;
            border-radius: var(--border-radius);
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--gray-200);
        }

        .section h2 {
            color: var(--gray-800);
            margin-bottom: 1.5rem;
            font-size: 1.5rem;
            font-weight: 600;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 0.5rem;
        }

        .grid {
            display: grid;
            gap: 1.5rem;
        }

        .grid-2 {
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--gray-700);
            font-size: 0.875rem;
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--gray-300);
            border-radius: var(--border-radius);
            font-size: 0.875rem;
            transition: var(--transition);
            background: white;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .form-input[type="password"] {
            font-family: 'Courier New', monospace;
        }

        .form-textarea {
            min-height: 100px;
            resize: vertical;
            font-family: 'Courier New', monospace;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: var(--border-radius);
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            text-decoration: none;
            margin-right: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .btn-primary {
            background: var(--primary-color);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--primary-hover);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .btn-secondary {
            background: var(--secondary-color);
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            background: var(--secondary-hover);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .btn-danger {
            background: var(--danger-color);
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: var(--danger-hover);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .btn-warning {
            background: var(--warning-color);
            color: white;
        }

        .btn-warning:hover:not(:disabled) {
            background: var(--warning-hover);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .btn-outline {
            background: transparent;
            border: 1px solid var(--gray-300);
            color: var(--gray-700);
        }

        .btn-outline:hover:not(:disabled) {
            background: var(--gray-50);
            border-color: var(--gray-400);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-sm {
            padding: 0.5rem 1rem;
            font-size: 0.75rem;
        }

        .alert {
            padding: 1rem;
            border-radius: var(--border-radius);
            margin-bottom: 1rem;
            border: 1px solid;
        }

        .alert-success {
            background: var(--success-bg);
            border-color: var(--success-border);
            color: var(--success-text);
        }

        .alert-error {
            background: var(--error-bg);
            border-color: var(--error-border);
            color: var(--error-text);
        }

        .alert-warning {
            background: var(--warning-bg);
            border-color: var(--warning-border);
            color: var(--warning-text);
        }

        .alert-info {
            background: var(--info-bg);
            border-color: var(--info-border);
            color: var(--info-text);
        }

        .code-block {
            background: var(--gray-50);
            border: 1px solid var(--gray-200);
            border-radius: var(--border-radius);
            padding: 1rem;
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
            white-space: pre-wrap;
            word-break: break-all;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 0.5rem;
        }

        .loading {
            opacity: 0.6;
            pointer-events: none;
        }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid transparent;
            border-top: 2px solid currentColor;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: var(--gray-200);
            border-radius: 2px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--primary-hover));
            width: 0%;
            transition: width 0.3s ease;
        }

        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .status-success {
            background: var(--success-bg);
            color: var(--success-text);
        }

        .status-error {
            background: var(--error-bg);
            color: var(--error-text);
        }

        .status-warning {
            background: var(--warning-bg);
            color: var(--warning-text);
        }

        .status-info {
            background: var(--info-bg);
            color: var(--info-text);
        }

        .card {
            background: white;
            border: 1px solid var(--gray-200);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            margin-bottom: 1rem;
        }

        .card-header {
            font-weight: 600;
            color: var(--gray-800);
            margin-bottom: 1rem;
        }

        .input-group {
            position: relative;
        }

        .input-group .form-input {
            padding-right: 2.5rem;
        }

        .input-group .btn {
            position: absolute;
            right: 0.25rem;
            top: 50%;
            transform: translateY(-50%);
            padding: 0.25rem 0.5rem;
            min-width: auto;
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: var(--gray-800);
            color: white;
            text-align: center;
            border-radius: 6px;
            padding: 5px 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.75rem;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .connection-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--danger-color);
        }

        .connection-dot.connected {
            background: var(--secondary-color);
        }

        .security-warning {
            background: var(--warning-bg);
            border: 1px solid var(--warning-border);
            color: var(--warning-text);
            padding: 1rem;
            border-radius: var(--border-radius);
            margin-bottom: 1rem;
        }

        .security-warning h4 {
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .network-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .network-info-item {
            display: flex;
            flex-direction: column;
        }

        .network-info-label {
            font-size: 0.75rem;
            color: var(--gray-500);
            margin-bottom: 0.25rem;
        }

        .network-info-value {
            font-weight: 500;
            color: var(--gray-800);
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .section {
                padding: 1.5rem;
            }
            
            .grid-2 {
                grid-template-columns: 1fr;
            }
            
            .btn {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚ö° Gasless Transaction Manager</h1>
            <p>Secure meta-transaction interface for ERC20 tokens</p>
        </div>

        <!-- Network Status -->
        <div class="section">
            <h2>üåê Network Status</h2>
            <div class="connection-status">
                <div class="connection-dot" id="connectionDot"></div>
                <span id="connectionStatus">Disconnected</span>
            </div>
            <div class="network-info" id="networkInfo">
                <!-- Network info will be populated here -->
            </div>
        </div>

        <!-- Configuration -->
        <div class="section">
            <h2>‚öôÔ∏è Configuration</h2>
            <div class="grid grid-2">
                <div class="form-group">
                    <label class="form-label" for="contractAddress">Contract Address</label>
                    <input type="text" 
                           id="contractAddress" 
                           class="form-input" 
                           value="0xd699187d5C26Ee6e85B0CEd886AeE676371B4574"
                           placeholder="0x..."
                           required>
                </div>
                <div class="form-group">
                    <label class="form-label" for="rpcUrl">RPC URL</label>
                    <input type="url" 
                           id="rpcUrl" 
                           class="form-input" 
                           value="https://polygon-amoy.g.alchemy.com/v2/fgPCE8UqEyFS3PnmIvAz6"
                           placeholder="https://..."
                           required>
                </div>
            </div>
            <div class="form-group">
                <button class="btn btn-primary" onclick="connectToNetwork()">
                    <span class="spinner" id="connectSpinner" style="display: none;"></span>
                    Connect to Network
                </button>
                <button class="btn btn-outline" onclick="validateContract()">Validate Contract</button>
            </div>
            <div id="configResults"></div>
        </div>

        <!-- Security Warning -->
        <div class="security-warning">
            <h4>üîí Security Notice</h4>
            <p>This application handles private keys for demonstration purposes. In production, use secure key management solutions like hardware wallets or key management services. Never share your private keys.</p>
        </div>

        <!-- Wallet Management -->
        <div class="section">
            <h2>üëõ Wallet Management</h2>
            <div class="grid grid-2">
                <div class="card">
                    <div class="card-header">User Wallet</div>
                    <div class="form-group">
                        <label class="form-label" for="userPrivateKey">Private Key</label>
                        <div class="input-group">
                            <input type="password" 
                                   id="userPrivateKey" 
                                   class="form-input" 
                                   placeholder="0x..."
                                   autocomplete="off">
                            <button class="btn btn-sm btn-outline" onclick="toggleVisibility('userPrivateKey')">üëÅÔ∏è</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Address</label>
                        <div class="code-block" id="userAddress">Not connected</div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Token Balance</label>
                        <div class="code-block" id="userBalance">-</div>
                    </div>
                </div>
                
                <div class="card">
                    <div class="card-header">Relayer Wallet</div>
                    <div class="form-group">
                        <label class="form-label" for="relayerPrivateKey">Private Key</label>
                        <div class="input-group">
                            <input type="password" 
                                   id="relayerPrivateKey" 
                                   class="form-input" 
                                   placeholder="0x..."
                                   autocomplete="off">
                            <button class="btn btn-sm btn-outline" onclick="toggleVisibility('relayerPrivateKey')">üëÅÔ∏è</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Address</label>
                        <div class="code-block" id="relayerAddress">Not connected</div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Authorization Status</label>
                        <div id="relayerStatus">
                            <span class="status-indicator status-error">Not Authorized</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="form-group">
                <button class="btn btn-secondary" onclick="generateTestWallets()">üîë Generate Test Wallets</button>
                <button class="btn btn-outline" onclick="updateWalletInfo()">üîÑ Refresh Wallet Info</button>
            </div>
        </div>

        <!-- Gasless Transaction -->
        <div class="section">
            <h2>‚ö° Gasless Transaction</h2>
            <div class="grid grid-2">
                <div class="form-group">
                    <label class="form-label" for="recipientAddress">Recipient Address</label>
                    <input type="text" 
                           id="recipientAddress" 
                           class="form-input" 
                           placeholder="0x..."
                           required>
                </div>
                <div class="form-group">
                    <label class="form-label" for="transferAmount">Amount (in tokens)</label>
                    <input type="number" 
                           id="transferAmount" 
                           class="form-input" 
                           step="0.000000000000000001"
                           min="0"
                           placeholder="1.0"
                           required>
                </div>
            </div>
            
            <div class="form-group">
                <button class="btn btn-primary" onclick="executeGaslessTransfer()" id="executeBtn">
                    <span class="spinner" id="executeSpinner" style="display: none;"></span>
                    Execute Gasless Transfer
                </button>
                <button class="btn btn-outline" onclick="simulateTransfer()">üß™ Simulate Transfer</button>
            </div>
            
            <div id="gaslessResults"></div>
        </div>

        <!-- Admin Tools -->
        <div class="section">
            <h2>üõ†Ô∏è Admin Tools</h2>
            <div class="form-group">
                <label class="form-label" for="ownerPrivateKey">Owner Private Key</label>
                <div class="input-group">
                    <input type="password" 
                           id="ownerPrivateKey" 
                           class="form-input" 
                           placeholder="0x..."
                           autocomplete="off">
                    <button class="btn btn-sm btn-outline" onclick="toggleVisibility('ownerPrivateKey')">üëÅÔ∏è</button>
                </div>
            </div>
            
            <div class="form-group">
                <button class="btn btn-warning" onclick="authorizeRelayer()">
                    <span class="spinner" id="authorizeSpinner" style="display: none;"></span>
                    Authorize Relayer
                </button>
                <button class="btn btn-secondary" onclick="mintTokens()">
                    <span class="spinner" id="mintSpinner" style="display: none;"></span>
                    Mint Test Tokens
                </button>
                <button class="btn btn-danger" onclick="revokeRelayer()">Revoke Relayer</button>
            </div>
            
            <div id="adminResults"></div>
        </div>

        <!-- Transaction History -->
        <div class="section">
            <h2>üìã Transaction History</h2>
            <div id="transactionHistory">
                <p class="text-gray-500">No transactions yet</p>
            </div>
        </div>
    </div>

    <script>
        // Application state
        const AppState = {
            provider: null,
            contract: null,
            networkInfo: null,
            isConnected: false,
            transactions: [],
            config: {
                contractAddress: '',
                rpcUrl: ''
            }
        };

        // Contract ABI
        const CONTRACT_ABI = [
            "function name() view returns (string)",
            "function symbol() view returns (string)",
            "function decimals() view returns (uint8)",
            "function totalSupply() view returns (uint256)",
            "function balanceOf(address) view returns (uint256)",
            "function nonces(address) view returns (uint256)",
            "function transfer(address to, uint256 amount) returns (bool)",
            "function approve(address spender, uint256 amount) returns (bool)",
            "function allowance(address owner, address spender) view returns (uint256)",
            "function authorizeRelayer(address relayer)",
            "function revokeRelayer(address relayer)",
            "function authorizedRelayers(address) view returns (bool)",
            "function executeMetaTransaction(address userAddress, bytes calldata functionSignature, bytes32 sigR, bytes32 sigS, uint8 sigV) payable returns (bytes memory)",
            "function getMetaTransactionHash(address userAddress, bytes calldata functionSignature, uint256 nonce) view returns (bytes32)",
            "function verifyMetaTransactionSignature(address userAddress, bytes calldata functionSignature, bytes32 sigR, bytes32 sigS, uint8 sigV) view returns (bool)",
            "function DOMAIN_SEPARATOR() view returns (bytes32)",
            "function getChainId() view returns (uint256)",
            "function mint(address to, uint256 amount)",
            "function burn(uint256 amount)",
            "function owner() view returns (address)",
            "event Transfer(address indexed from, address indexed to, uint256 value)",
            "event Approval(address indexed owner, address indexed spender, uint256 value)",
            "event MetaTransactionExecuted(address userAddress, address relayerAddress, bytes functionSignature)"
        ];

        // Utility functions
        const Utils = {
            formatAddress: (address) => {
                if (!address) return 'N/A';
                return `${address.slice(0, 6)}...${address.slice(-4)}`;
            },

            formatTokenAmount: (amount, decimals = 18) => {
                if (!amount) return '0';
                return ethers.formatUnits(amount, decimals);
            },

            parseTokenAmount: (amount, decimals = 18) => {
                if (!amount) return '0';
                return ethers.parseUnits(amount.toString(), decimals);
            },

            showAlert: (elementId, message, type = 'info') => {
                const element = document.getElementById(elementId);
                if (!element) return;

                element.innerHTML = `
                    <div class="alert alert-${type}">
                        ${message}
                    </div>
                `;
            },

            showSpinner: (spinnerId, show = true) => {
                const spinner = document.getElementById(spinnerId);
                if (spinner) {
                    spinner.style.display = show ? 'inline-block' : 'none';
                }
            },

            validateAddress: (address) => {
                try {
                    return ethers.isAddress(address);
                } catch {
                    return false;
                }
            },

            validatePrivateKey: (privateKey) => {
                try {
                    new ethers.Wallet(privateKey);
                    return true;
                } catch {
                    return false;
                }
            },

            getWalletFromPrivateKey: (privateKey) => {
                try {
                    return new ethers.Wallet(privateKey);
                } catch (error) {
                    throw new Error('Invalid private key');
                }
            },

            addTransaction: (tx) => {
                AppState.transactions.unshift({
                    ...tx,
                    timestamp: new Date().toISOString()
                });
                updateTransactionHistory();
            }
        };

        // Network management
        async function connectToNetwork() {
            try {
                Utils.showSpinner('connectSpinner', true);
                updateConnectionStatus('Connecting...', false);

                const contractAddress = document.getElementById('contractAddress').value.trim();
                const rpcUrl = document.getElementById('rpcUrl').value.trim();

                // Validate inputs
                if (!contractAddress || !rpcUrl) {
                    throw new Error('Please provide both contract address and RPC URL');
                }

                if (!Utils.validateAddress(contractAddress)) {
                    throw new Error('Invalid contract address');
                }

                // Update config
                AppState.config.contractAddress = contractAddress;
                AppState.config.rpcUrl = rpcUrl;

                // Create provider
                AppState.provider = new ethers.JsonRpcProvider(rpcUrl);

                // Test connection
                const network = await AppState.provider.getNetwork();
                AppState.networkInfo = {
                    name: network.name,
                    chainId: network.chainId.toString(),
                    blockNumber: await AppState.provider.getBlockNumber()
                };

                // Create contract instance
                AppState.contract = new ethers.Contract(contractAddress, CONTRACT_ABI, AppState.provider);

                // Test contract
                await AppState.contract.name();

                AppState.isConnected = true;
                updateConnectionStatus('Connected', true);
                updateNetworkInfo();
                Utils.showAlert('configResults', '‚úÖ Successfully connected to network and contract!', 'success');

            } catch (error) {
                AppState.isConnected = false;
                updateConnectionStatus('Connection Failed', false);
                Utils.showAlert('configResults', `‚ùå Connection failed: ${error.message}`, 'error');
            } finally {
                Utils.showSpinner('connectSpinner', false);
            }
        }

        async function validateContract() {
            if (!AppState.isConnected) {
                Utils.showAlert('configResults', '‚ùå Please connect to network first', 'error');
                return;
            }

            try {
                const contract = AppState.contract;
                
                // Test basic ERC20 functions
                const name = await contract.name();
                const symbol = await contract.symbol();
                const decimals = await contract.decimals();
                const totalSupply = await contract.totalSupply();

                // Test gasless-specific functions
                const domainSeparator = await contract.DOMAIN_SEPARATOR();
                const chainId = await contract.getChainId();

                const validationResult = `
                    <strong>Contract Validation Results:</strong><br>
                    Name: ${name}<br>
                    Symbol: ${symbol}<br>
                    Decimals: ${decimals}<br>
                    Total Supply: ${Utils.formatTokenAmount(totalSupply)} tokens<br>
                    Domain Separator: ${domainSeparator}<br>
                    Chain ID: ${chainId}<br>
                    ‚úÖ Contract is valid and supports gasless transactions
                `;

                Utils.showAlert('configResults', validationResult, 'success');

            } catch (error) {
                Utils.showAlert('configResults', `‚ùå Contract validation failed: ${error.message}`, 'error');
            }
        }

        function updateConnectionStatus(status, connected) {
            const dot = document.getElementById('connectionDot');
            const statusText = document.getElementById('connectionStatus');
            
            if (connected) {
                dot.classList.add('connected');
            } else {
                dot.classList.remove('connected');
            }
            
            statusText.textContent = status;
        }

    function updateNetworkInfo() {
        const networkInfoDiv = document.getElementById('networkInfo');
        
        if (!AppState.networkInfo) {
            networkInfoDiv.innerHTML = '<p>No network information available</p>';
            return;
        }
        
        networkInfoDiv.innerHTML = `
            <div class="network-info-item">
                <div class="network-info-label">Network</div>
                <div class="network-info-value">${AppState.networkInfo.name}</div>
            </div>
            <div class="network-info-item">
                <div class="network-info-label">Chain ID</div>
                <div class="network-info-value">${AppState.networkInfo.chainId}</div>
            </div>
            <div class="network-info-item">
                <div class="network-info-label">Block Number</div>
                <div class="network-info-value">${AppState.networkInfo.blockNumber}</div>
            </div>
            <div class="network-info-item">
                <div class="network-info-label">Contract</div>
                <div class="network-info-value">${Utils.formatAddress(AppState.config.contractAddress)}</div>
            </div>
        `;
    }

    // Wallet management functions
    async function generateTestWallets() {
        try {
            // Generate two random wallets
            const userWallet = ethers.Wallet.createRandom();
            const relayerWallet = ethers.Wallet.createRandom();
            
            // Fill in the private keys
            document.getElementById('userPrivateKey').value = userWallet.privateKey;
            document.getElementById('relayerPrivateKey').value = relayerWallet.privateKey;
            
            // Update wallet info
            await updateWalletInfo();
            
            Utils.showAlert('adminResults', '‚úÖ Test wallets generated successfully!', 'success');
            
        } catch (error) {
            Utils.showAlert('adminResults', `‚ùå Error generating wallets: ${error.message}`, 'error');
        }
    }

    async function updateWalletInfo() {
        if (!AppState.isConnected) {
            Utils.showAlert('adminResults', '‚ùå Please connect to network first', 'error');
            return;
        }

        try {
            const userPrivateKey = document.getElementById('userPrivateKey').value.trim();
            const relayerPrivateKey = document.getElementById('relayerPrivateKey').value.trim();
            
            // Update user wallet info
            if (userPrivateKey && Utils.validatePrivateKey(userPrivateKey)) {
                const userWallet = Utils.getWalletFromPrivateKey(userPrivateKey);
                document.getElementById('userAddress').textContent = userWallet.address;
                
                // Get token balance
                const balance = await AppState.contract.balanceOf(userWallet.address);
                const decimals = await AppState.contract.decimals();
                document.getElementById('userBalance').textContent = 
                    `${Utils.formatTokenAmount(balance, decimals)} tokens`;
            } else {
                document.getElementById('userAddress').textContent = 'Invalid private key';
                document.getElementById('userBalance').textContent = '-';
            }
            
            // Update relayer wallet info
            if (relayerPrivateKey && Utils.validatePrivateKey(relayerPrivateKey)) {
                const relayerWallet = Utils.getWalletFromPrivateKey(relayerPrivateKey);
                document.getElementById('relayerAddress').textContent = relayerWallet.address;
                
                // Check authorization status
                const isAuthorized = await AppState.contract.authorizedRelayers(relayerWallet.address);
                const statusElement = document.getElementById('relayerStatus');
                
                if (isAuthorized) {
                    statusElement.innerHTML = '<span class="status-indicator status-success">‚úÖ Authorized</span>';
                } else {
                    statusElement.innerHTML = '<span class="status-indicator status-error">‚ùå Not Authorized</span>';
                }
            } else {
                document.getElementById('relayerAddress').textContent = 'Invalid private key';
                document.getElementById('relayerStatus').innerHTML = '<span class="status-indicator status-error">‚ùå Invalid Key</span>';
            }
            
        } catch (error) {
            console.error('Error updating wallet info:', error);
            Utils.showAlert('adminResults', `‚ùå Error updating wallet info: ${error.message}`, 'error');
        }
    }

    function toggleVisibility(inputId) {
        const input = document.getElementById(inputId);
        const button = input.nextElementSibling;
        
        if (input.type === 'password') {
            input.type = 'text';
            button.textContent = 'üôà';
        } else {
            input.type = 'password';
            button.textContent = 'üëÅÔ∏è';
        }
    }

    // Gasless transaction functions
    async function simulateTransfer() {
        if (!AppState.isConnected) {
            Utils.showAlert('gaslessResults', '‚ùå Please connect to network first', 'error');
            return;
        }

        try {
            const userPrivateKey = document.getElementById('userPrivateKey').value.trim();
            const recipientAddress = document.getElementById('recipientAddress').value.trim();
            const transferAmount = document.getElementById('transferAmount').value.trim();
            
            // Validate inputs
            if (!userPrivateKey || !Utils.validatePrivateKey(userPrivateKey)) {
                throw new Error('Invalid user private key');
            }
            
            if (!recipientAddress || !Utils.validateAddress(recipientAddress)) {
                throw new Error('Invalid recipient address');
            }
            
            if (!transferAmount || isNaN(transferAmount) || parseFloat(transferAmount) <= 0) {
                throw new Error('Invalid transfer amount');
            }
            
            const userWallet = Utils.getWalletFromPrivateKey(userPrivateKey);
            const decimals = await AppState.contract.decimals();
            const amount = Utils.parseTokenAmount(transferAmount, decimals);
            
            // Check balance
            const balance = await AppState.contract.balanceOf(userWallet.address);
            if (balance < amount) {
                throw new Error('Insufficient balance');
            }
            
            // Simulate the transaction
            const simulationResult = `
                <strong>Transaction Simulation:</strong><br>
                From: ${userWallet.address}<br>
                To: ${recipientAddress}<br>
                Amount: ${transferAmount} tokens<br>
                Current Balance: ${Utils.formatTokenAmount(balance, decimals)} tokens<br>
                Remaining Balance: ${Utils.formatTokenAmount(balance - amount, decimals)} tokens<br>
                ‚úÖ Transaction is valid and ready to execute
            `;
            
            Utils.showAlert('gaslessResults', simulationResult, 'info');
            
        } catch (error) {
            Utils.showAlert('gaslessResults', `‚ùå Simulation failed: ${error.message}`, 'error');
        }
    }

  
  // ===========================================
// LOCATION 1: Add these helper functions BEFORE your executeGaslessTransfer function
// ===========================================

async function calculateOptimalGasPrice(provider) {
    try {
        const feeData = await provider.getFeeData();
        console.log('üìä Network fee data:', {
            gasPrice: feeData.gasPrice ? ethers.formatUnits(feeData.gasPrice, 'gwei') + ' gwei' : 'N/A',
            maxFeePerGas: feeData.maxFeePerGas ? ethers.formatUnits(feeData.maxFeePerGas, 'gwei') + ' gwei' : 'N/A',
            maxPriorityFeePerGas: feeData.maxPriorityFeePerGas ? ethers.formatUnits(feeData.maxPriorityFeePerGas, 'gwei') + ' gwei' : 'N/A'
        });

        // For Polygon networks, prioritize maxFeePerGas if available (EIP-1559)
        if (feeData.maxFeePerGas && feeData.maxPriorityFeePerGas) {
            console.log('Using EIP-1559 pricing');
            
            // Use the higher of network gasPrice or maxFeePerGas as base
            const baseGasPrice = feeData.gasPrice || ethers.parseUnits('50', 'gwei');
            const networkMaxFee = feeData.maxFeePerGas;
            
            // Take the higher value as our base and multiply by our factor
            const higherBase = baseGasPrice > networkMaxFee ? baseGasPrice : networkMaxFee;
            const multipliedMaxFee = higherBase * 5n; // Increased to 5x multiplier for reliability
            
            // Set higher minimums for Polygon Amoy (testnet can be congested)
            const minMaxFee = ethers.parseUnits('500', 'gwei'); // Increased minimum
            const minPriorityFee = ethers.parseUnits('100', 'gwei'); // Increased minimum
            
            const finalMaxFee = multipliedMaxFee > minMaxFee ? multipliedMaxFee : minMaxFee;
            const finalPriorityFee = (feeData.maxPriorityFeePerGas * 5n) > minPriorityFee ? 
                (feeData.maxPriorityFeePerGas * 5n) : minPriorityFee;
            
            console.log('‚õΩ EIP-1559 gas calculation:', {
                baseGasPrice: ethers.formatUnits(baseGasPrice, 'gwei') + ' gwei',
                networkMaxFee: ethers.formatUnits(networkMaxFee, 'gwei') + ' gwei',
                finalMaxFee: ethers.formatUnits(finalMaxFee, 'gwei') + ' gwei',
                finalPriorityFee: ethers.formatUnits(finalPriorityFee, 'gwei') + ' gwei'
            });
            
            return {
                maxFeePerGas: finalMaxFee,
                maxPriorityFeePerGas: finalPriorityFee,
                gasPrice: undefined // Don't use legacy gasPrice with EIP-1559
            };
        }

        // Fallback to legacy gas pricing with higher multiplier
        const networkGasPrice = feeData.gasPrice || ethers.parseUnits('50', 'gwei');
        const gasPrice = networkGasPrice * 5n; // Increased to 5x multiplier
        const minGasPrice = ethers.parseUnits('500', 'gwei'); // Higher minimum for Polygon Amoy
        const finalGasPrice = gasPrice > minGasPrice ? gasPrice : minGasPrice;

        console.log('‚õΩ Using legacy gas pricing:', {
            networkGasPrice: ethers.formatUnits(networkGasPrice, 'gwei') + ' gwei',
            calculatedGasPrice: ethers.formatUnits(gasPrice, 'gwei') + ' gwei',
            finalGasPrice: ethers.formatUnits(finalGasPrice, 'gwei') + ' gwei'
        });

        return {
            gasPrice: finalGasPrice,
            maxFeePerGas: undefined,
            maxPriorityFeePerGas: undefined
        };
    } catch (error) {
        console.error('Error calculating gas price:', error);
        // Ultra-safe fallback for Polygon Amoy
        return {
            gasPrice: ethers.parseUnits('600', 'gwei'),
            maxFeePerGas: undefined,
            maxPriorityFeePerGas: undefined
        };
    }
} 

// Transaction status checker function
async function checkTransactionStatus(txHash, provider) {
    try {
        console.log(`üîç Checking status for transaction: ${txHash}`);
        
        // Check if transaction exists
        const tx = await provider.getTransaction(txHash);
        if (!tx) {
            return { status: 'not_found', message: 'Transaction not found in mempool' };
        }
        
        console.log('Transaction found:', {
            hash: tx.hash,
            blockNumber: tx.blockNumber,
            gasPrice: ethers.formatUnits(tx.gasPrice, 'gwei') + ' gwei',
            gasLimit: tx.gasLimit.toString()
        });
        
        // Check if transaction is pending
        if (tx.blockNumber === null) {
            return { 
                status: 'pending', 
                message: 'Transaction is still pending in mempool',
                details: tx
            };
        }
        
        // Get transaction receipt
        const receipt = await provider.getTransactionReceipt(txHash);
        if (!receipt) {
            return { 
                status: 'pending', 
                message: 'Transaction mined but receipt not yet available' 
            };
        }
        
        // Check transaction success
        if (receipt.status === 1) {
            return { 
                status: 'success', 
                message: 'Transaction confirmed successfully',
                receipt: receipt
            };
        } else {
            return { 
                status: 'failed', 
                message: 'Transaction failed/reverted',
                receipt: receipt
            };
        }
        
    } catch (error) {
        console.error('Error checking transaction status:', error);
        return { 
            status: 'error', 
            message: `Error checking status: ${error.message}` 
        };
    }
}

// Enhanced transaction execution with retry logic
async function executeTransactionWithRetry(contractWithRelayer, params, maxRetries = 2) {
    let lastError;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            console.log(`üîÑ Transaction attempt ${attempt}/${maxRetries}`);
            
            // Calculate gas settings for this attempt
            const gasSettings = await calculateOptimalGasPrice(AppState.provider);
            
            // Increase gas price with each retry
            if (attempt > 1) {
                if (gasSettings.gasPrice) {
                    gasSettings.gasPrice = gasSettings.gasPrice * BigInt(attempt);
                }
                if (gasSettings.maxFeePerGas) {
                    gasSettings.maxFeePerGas = gasSettings.maxFeePerGas * BigInt(attempt);
                    gasSettings.maxPriorityFeePerGas = gasSettings.maxPriorityFeePerGas * BigInt(attempt);
                }
            }
            
            // Estimate gas with retry logic
            let gasEstimate;
            try {
                gasEstimate = await contractWithRelayer.executeMetaTransaction.estimateGas(
                    params.userAddress,
                    params.functionSignature,
                    params.sigR,
                    params.sigS,
                    params.sigV
                );
            } catch (estimateError) {
                console.error(`Gas estimation failed on attempt ${attempt}:`, estimateError);
                if (attempt === maxRetries) throw estimateError;
                continue;
            }
            
            // Use higher gas limit for retries
            const gasMultiplier = attempt === 1 ? 2n : 3n;
            const gasLimit = gasEstimate * gasMultiplier > 500000n ? gasEstimate * gasMultiplier : 500000n;
            
            console.log(`‚õΩ Gas settings for attempt ${attempt}:`, {
                gasLimit: gasLimit.toString(),
                gasPrice: gasSettings.gasPrice ? ethers.formatUnits(gasSettings.gasPrice, 'gwei') + ' gwei' : 'N/A',
                maxFeePerGas: gasSettings.maxFeePerGas ? ethers.formatUnits(gasSettings.maxFeePerGas, 'gwei') + ' gwei' : 'N/A',
                maxPriorityFeePerGas: gasSettings.maxPriorityFeePerGas ? ethers.formatUnits(gasSettings.maxPriorityFeePerGas, 'gwei') + ' gwei' : 'N/A'
            });
            
            // Prepare transaction options
            const txOptions = { gasLimit };
            if (gasSettings.gasPrice) {
                txOptions.gasPrice = gasSettings.gasPrice;
            } else {
                txOptions.maxFeePerGas = gasSettings.maxFeePerGas;
                txOptions.maxPriorityFeePerGas = gasSettings.maxPriorityFeePerGas;
            }
            
            // Execute transaction
            const tx = await contractWithRelayer.executeMetaTransaction(
                params.userAddress,
                params.functionSignature,
                params.sigR,
                params.sigS,
                params.sigV,
                txOptions
            );
            
            console.log(`‚úÖ Transaction submitted on attempt ${attempt}:`, tx.hash);
            
            // Wait for confirmation with progressive timeout
            const confirmationTimeout = attempt === 1 ? 120000 : 180000; // 2 min first, then 3 min
            
            const confirmationPromise = tx.wait();
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error(`Confirmation timeout after ${confirmationTimeout/1000} seconds`)), confirmationTimeout);
            });
            
            const receipt = await Promise.race([confirmationPromise, timeoutPromise]);
            
            console.log(`‚úÖ Transaction confirmed on attempt ${attempt}:`, receipt.transactionHash);
            return { tx, receipt };
            
        } catch (error) {
            console.error(`‚ùå Attempt ${attempt} failed:`, error);
            lastError = error;
            
            // Don't retry for certain errors
            if (error.code === 'CALL_EXCEPTION' || 
                error.message.includes('Invalid signature') ||
                error.message.includes('Invalid nonce')) {
                throw error;
            }
            
            // Wait before retry (exponential backoff)
            if (attempt < maxRetries) {
                const delay = Math.pow(2, attempt) * 1000; // 2s, 4s, 8s...
                console.log(`‚è≥ Waiting ${delay}ms before retry...`);
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    
    throw lastError;
}

// ===========================================
// LOCATION 2: REPLACE the entire executeGaslessTransfer function with this updated version
// ===========================================

async function executeGaslessTransfer() {
    if (!AppState.isConnected) {
        Utils.showAlert('gaslessResults', '‚ùå Please connect to network first', 'error');
        return;
    }

    try {
        Utils.showSpinner('executeSpinner', true);
        document.getElementById('executeBtn').disabled = true;
        
        const userPrivateKey = document.getElementById('userPrivateKey').value.trim();
        const relayerPrivateKey = document.getElementById('relayerPrivateKey').value.trim();
        const recipientAddress = document.getElementById('recipientAddress').value.trim();
        const transferAmount = document.getElementById('transferAmount').value.trim();
        
        // Validate inputs
        if (!userPrivateKey || !Utils.validatePrivateKey(userPrivateKey)) {
            throw new Error('Invalid user private key');
        }
        
        if (!relayerPrivateKey || !Utils.validatePrivateKey(relayerPrivateKey)) {
            throw new Error('Invalid relayer private key');
        }
        
        if (!recipientAddress || !Utils.validateAddress(recipientAddress)) {
            throw new Error('Invalid recipient address');
        }
        
        if (!transferAmount || isNaN(transferAmount) || parseFloat(transferAmount) <= 0) {
            throw new Error('Invalid transfer amount');
        }
        
        const userWallet = Utils.getWalletFromPrivateKey(userPrivateKey);
        const relayerWallet = Utils.getWalletFromPrivateKey(relayerPrivateKey).connect(AppState.provider);
        const decimals = await AppState.contract.decimals();
        const amount = Utils.parseTokenAmount(transferAmount, decimals);
        
        console.log('üîç Debug Info:');
        console.log('User Address:', userWallet.address);
        console.log('Relayer Address:', relayerWallet.address);
        console.log('Recipient Address:', recipientAddress);
        console.log('Amount:', amount.toString());
        
        // Check if relayer is authorized
        const isAuthorized = await AppState.contract.authorizedRelayers(relayerWallet.address);
        console.log('Relayer authorized:', isAuthorized);
        if (!isAuthorized) {
            throw new Error('Relayer is not authorized. Please authorize the relayer first.');
        }
        
        // Check balance
        const balance = await AppState.contract.balanceOf(userWallet.address);
        console.log('User balance:', balance.toString());
        console.log('Transfer amount:', amount.toString());
        if (balance < amount) {
            throw new Error('Insufficient balance');
        }
        
        // Prepare the function signature for transfer
        const functionSignature = AppState.contract.interface.encodeFunctionData('transfer', [
            recipientAddress,
            amount
        ]);
        console.log('Function signature:', functionSignature);
        
        // Get current nonce
        const nonce = await AppState.contract.nonces(userWallet.address);
        console.log('Current nonce:', nonce.toString());
        
        // Create the meta-transaction hash
        const metaTxHash = await AppState.contract.getMetaTransactionHash(
            userWallet.address,
            functionSignature,
            nonce
        );
        console.log('Meta-transaction hash:', metaTxHash);
        
        // EIP-712 signature
        const domain = {
            name: await AppState.contract.name(),
            version: "1",
            chainId: await AppState.contract.getChainId(),
            verifyingContract: await AppState.contract.getAddress()
        };
        
        const types = {
            MetaTransaction: [
                { name: "nonce", type: "uint256" },
                { name: "from", type: "address" },
                { name: "functionSignature", type: "bytes" }
            ]
        };
        
        const value = {
            nonce: nonce,
            from: userWallet.address,
            functionSignature: functionSignature
        };
        
        // Sign using EIP-712 typed data
        const signature = await userWallet.signTypedData(domain, types, value);
        const sigParams = ethers.Signature.from(signature);
        
        console.log('Signature components:', {
            r: sigParams.r,
            s: sigParams.s,
            v: sigParams.v
        });
        
        // Verify signature before sending transaction
        const isValidSig = await AppState.contract.verifyMetaTransactionSignature(
            userWallet.address,
            functionSignature,
            sigParams.r,
            sigParams.s,
            sigParams.v
        );
        
        console.log('Signature verification result:', isValidSig);
        
        if (!isValidSig) {
            throw new Error('‚ùå Signature verification failed. Check your private key and try again.');
        }
        
        Utils.showAlert('gaslessResults', '‚úÖ Signature verified. Executing transaction...', 'info');
        
        // Check relayer balance first
        const relayerBalance = await AppState.provider.getBalance(relayerWallet.address);
        console.log('üí∞ Relayer balance:', ethers.formatEther(relayerBalance), 'MATIC');
        
        if (relayerBalance < ethers.parseEther('0.01')) {
            throw new Error('Relayer has insufficient MATIC balance for gas fees');
        }
        
        // Execute the meta-transaction with enhanced retry logic
        const contractWithRelayer = AppState.contract.connect(relayerWallet);
        
        Utils.showAlert('gaslessResults', '‚è≥ Submitting transaction...', 'info');
        
        // Use the enhanced transaction execution with retry
        const { tx, receipt } = await executeTransactionWithRetry(contractWithRelayer, {
            userAddress: userWallet.address,
            functionSignature: functionSignature,
            sigR: sigParams.r,
            sigS: sigParams.s,
            sigV: sigParams.v
        });
        
        console.log('‚úÖ Transaction confirmed:', receipt);
        
        // Update wallet info
        await updateWalletInfo();
        
        // Add to transaction history
        Utils.addTransaction({
            hash: tx.hash,
            from: userWallet.address,
            to: recipientAddress,
            amount: transferAmount,
            type: 'Gasless Transfer',
            status: 'confirmed',
            gasUsed: receipt.gasUsed.toString(),
            relayer: relayerWallet.address
        });
        
        const successMessage = `
            <strong>‚úÖ Gasless Transfer Successful!</strong><br>
            Transaction Hash: ${tx.hash}<br>
            From: ${Utils.formatAddress(userWallet.address)}<br>
            To: ${Utils.formatAddress(recipientAddress)}<br>
            Amount: ${transferAmount} tokens<br>
            Gas Used: ${receipt.gasUsed}<br>
            Gas Price: ${receipt.effectiveGasPrice ? ethers.formatUnits(receipt.effectiveGasPrice, 'gwei') + ' gwei' : 'N/A'}<br>
            Relayer: ${Utils.formatAddress(relayerWallet.address)}
        `;
        
        Utils.showAlert('gaslessResults', successMessage, 'success');
        
    } catch (error) {
        console.error('‚ùå Full error details:', error);
        
        // Enhanced error handling with transaction status checking
        let errorMessage = error.message;
        
        // If it's a timeout and we have a transaction hash, check its status
        if (error.message.includes('timeout') && typeof tx !== 'undefined' && tx.hash) {
            Utils.showAlert('gaslessResults', '‚è≥ Transaction timed out, checking status...', 'info');
            
            const status = await checkTransactionStatus(tx.hash, AppState.provider);
            
            if (status.status === 'success') {
                // Transaction actually succeeded!
                const receipt = status.receipt;
                
                // Update wallet info
                await updateWalletInfo();
                
                // Add to transaction history
                Utils.addTransaction({
                    hash: tx.hash,
                    from: userWallet.address,
                    to: recipientAddress,
                    amount: transferAmount,
                    type: 'Gasless Transfer',
                    status: 'confirmed',
                    gasUsed: receipt.gasUsed.toString(),
                    relayer: relayerWallet.address
                });
                
                const successMessage = `
                    <strong>‚úÖ Gasless Transfer Successful!</strong><br>
                    <small>(Confirmed after timeout)</small><br>
                    Transaction Hash: ${tx.hash}<br>
                    From: ${Utils.formatAddress(userWallet.address)}<br>
                    To: ${Utils.formatAddress(recipientAddress)}<br>
                    Amount: ${transferAmount} tokens<br>
                    Gas Used: ${receipt.gasUsed}<br>
                    Relayer: ${Utils.formatAddress(relayerWallet.address)}
                `;
                
                Utils.showAlert('gaslessResults', successMessage, 'success');
                return; // Exit successfully
            } else if (status.status === 'pending') {
                errorMessage = `Transaction is still pending. Hash: ${tx.hash}. Check blockchain explorer for updates.`;
            } else if (status.status === 'failed') {
                errorMessage = `Transaction failed on blockchain. Hash: ${tx.hash}`;
            } else {
                errorMessage = `${status.message}. Hash: ${tx.hash}`;
            }
        } else {
            // Original error handling for other cases
            if (error.code === 'TIMEOUT') {
                errorMessage = 'Transaction timed out. Please try again with higher gas price.';
            } else if (error.code === 'INSUFFICIENT_FUNDS') {
                errorMessage = 'Relayer has insufficient funds for gas fees.';
            } else if (error.code === 'CALL_EXCEPTION') {
                // Handle specific contract errors
                if (error.data) {
                    const errorCodes = {
                        '0x8baa579f': 'Invalid signature',
                        '0x756688fe': 'Invalid nonce',
                        '0x82b42900': 'Unauthorized relayer',
                        '0x8d21e65e': 'Execution failed'
                    };
                    errorMessage = errorCodes[error.data] || `Contract error: ${error.data}`;
                }
            } else if (error.code === 'NETWORK_ERROR') {
                errorMessage = 'Network error. Please check your connection and try again.';
            } else if (error.message.includes('timeout')) {
                errorMessage = 'Transaction confirmation timed out. Check blockchain explorer for status.';
            }
        }
        
        Utils.showAlert('gaslessResults', `‚ùå Transaction failed: ${errorMessage}`, 'error');
    } finally {
        Utils.showSpinner('executeSpinner', false);
        document.getElementById('executeBtn').disabled = false;
    }
} 
    // Admin functions
    async function authorizeRelayer() {
        if (!AppState.isConnected) {
            Utils.showAlert('adminResults', '‚ùå Please connect to network first', 'error');
            return;
        }

        try {
            Utils.showSpinner('authorizeSpinner', true);
            
            const ownerPrivateKey = document.getElementById('ownerPrivateKey').value.trim();
            const relayerPrivateKey = document.getElementById('relayerPrivateKey').value.trim();
            
            if (!ownerPrivateKey || !Utils.validatePrivateKey(ownerPrivateKey)) {
                throw new Error('Invalid owner private key');
            }
            
            if (!relayerPrivateKey || !Utils.validatePrivateKey(relayerPrivateKey)) {
                throw new Error('Invalid relayer private key');
            }
            
            const ownerWallet = Utils.getWalletFromPrivateKey(ownerPrivateKey).connect(AppState.provider);
            const relayerWallet = Utils.getWalletFromPrivateKey(relayerPrivateKey);
            
            // Check if the owner is actually the owner
            const contractOwner = await AppState.contract.owner();
            if (ownerWallet.address.toLowerCase() !== contractOwner.toLowerCase()) {
                throw new Error('Provided private key is not the contract owner');
            }
            
            const contractWithOwner = AppState.contract.connect(ownerWallet);
            const tx = await contractWithOwner.authorizeRelayer(relayerWallet.address);
            
            Utils.showAlert('adminResults', `‚è≥ Authorization transaction submitted: ${tx.hash}`, 'info');
            
            const receipt = await tx.wait();
            
            // Update wallet info
            await updateWalletInfo();
            
            Utils.addTransaction({
                hash: tx.hash,
                from: ownerWallet.address,
                to: relayerWallet.address,
                type: 'Authorize Relayer',
                status: 'confirmed',
                gasUsed: receipt.gasUsed.toString()
            });
            
            Utils.showAlert('adminResults', `‚úÖ Relayer authorized successfully! Transaction: ${tx.hash}`, 'success');
            
        } catch (error) {
            Utils.showAlert('adminResults', `‚ùå Authorization failed: ${error.message}`, 'error');
        } finally {
            Utils.showSpinner('authorizeSpinner', false);
        }
    }

    async function revokeRelayer() {
        if (!AppState.isConnected) {
            Utils.showAlert('adminResults', '‚ùå Please connect to network first', 'error');
            return;
        }

        try {
            const ownerPrivateKey = document.getElementById('ownerPrivateKey').value.trim();
            const relayerPrivateKey = document.getElementById('relayerPrivateKey').value.trim();
            
            if (!ownerPrivateKey || !Utils.validatePrivateKey(ownerPrivateKey)) {
                throw new Error('Invalid owner private key');
            }
            
            if (!relayerPrivateKey || !Utils.validatePrivateKey(relayerPrivateKey)) {
                throw new Error('Invalid relayer private key');
            }
            
            const ownerWallet = Utils.getWalletFromPrivateKey(ownerPrivateKey).connect(AppState.provider);
            const relayerWallet = Utils.getWalletFromPrivateKey(relayerPrivateKey);
            
            // Check if the owner is actually the owner
            const contractOwner = await AppState.contract.owner();
            if (ownerWallet.address.toLowerCase() !== contractOwner.toLowerCase()) {
                throw new Error('Provided private key is not the contract owner');
            }
            
            const contractWithOwner = AppState.contract.connect(ownerWallet);
            const tx = await contractWithOwner.revokeRelayer(relayerWallet.address);
            
            Utils.showAlert('adminResults', `‚è≥ Revocation transaction submitted: ${tx.hash}`, 'info');
            
            const receipt = await tx.wait();
            
            // Update wallet info
            await updateWalletInfo();
            
            Utils.addTransaction({
                hash: tx.hash,
                from: ownerWallet.address,
                to: relayerWallet.address,
                type: 'Revoke Relayer',
                status: 'confirmed',
                gasUsed: receipt.gasUsed.toString()
            });
            
            Utils.showAlert('adminResults', `‚úÖ Relayer revoked successfully! Transaction: ${tx.hash}`, 'success');
            
        } catch (error) {
            Utils.showAlert('adminResults', `‚ùå Revocation failed: ${error.message}`, 'error');
        }
    }

    async function mintTokens() {
        if (!AppState.isConnected) {
            Utils.showAlert('adminResults', '‚ùå Please connect to network first', 'error');
            return;
        }

        try {
            Utils.showSpinner('mintSpinner', true);
            
            const ownerPrivateKey = document.getElementById('ownerPrivateKey').value.trim();
            const userPrivateKey = document.getElementById('userPrivateKey').value.trim();
            
            if (!ownerPrivateKey || !Utils.validatePrivateKey(ownerPrivateKey)) {
                throw new Error('Invalid owner private key');
            }
            
            if (!userPrivateKey || !Utils.validatePrivateKey(userPrivateKey)) {
                throw new Error('Invalid user private key (recipient)');
            }
            
            const ownerWallet = Utils.getWalletFromPrivateKey(ownerPrivateKey).connect(AppState.provider);
            const userWallet = Utils.getWalletFromPrivateKey(userPrivateKey);
            
            // Check if the owner is actually the owner
            const contractOwner = await AppState.contract.owner();
            if (ownerWallet.address.toLowerCase() !== contractOwner.toLowerCase()) {
                throw new Error('Provided private key is not the contract owner');
            }
            
            const decimals = await AppState.contract.decimals();
            const mintAmount = Utils.parseTokenAmount('1000', decimals); // Mint 1000 tokens
            
            const contractWithOwner = AppState.contract.connect(ownerWallet);
            const tx = await contractWithOwner.mint(userWallet.address, mintAmount);
            
            Utils.showAlert('adminResults', `‚è≥ Mint transaction submitted: ${tx.hash}`, 'info');
            
            const receipt = await tx.wait();
            
            // Update wallet info
            await updateWalletInfo();
            
            Utils.addTransaction({
                hash: tx.hash,
                from: ownerWallet.address,
                to: userWallet.address,
                amount: '1000',
                type: 'Mint Tokens',
                status: 'confirmed',
                gasUsed: receipt.gasUsed.toString()
            });
            
            Utils.showAlert('adminResults', `‚úÖ Tokens minted successfully! Transaction: ${tx.hash}`, 'success');
            
        } catch (error) {
            Utils.showAlert('adminResults', `‚ùå Minting failed: ${error.message}`, 'error');
        } finally {
            Utils.showSpinner('mintSpinner', false);
        }
    }

    // Transaction history
    function updateTransactionHistory() {
        const historyDiv = document.getElementById('transactionHistory');
        
        if (AppState.transactions.length === 0) {
            historyDiv.innerHTML = '<p class="text-gray-500">No transactions yet</p>';
            return;
        }
        
        const historyHTML = AppState.transactions.map(tx => `
            <div class="card">
                <div class="card-header">
                    <span class="status-indicator status-${tx.status === 'confirmed' ? 'success' : 'warning'}">
                        ${tx.status === 'confirmed' ? '‚úÖ' : '‚è≥'} ${tx.type}
                    </span>
                    <span style="float: right; font-size: 0.75rem; color: var(--gray-500);">
                        ${new Date(tx.timestamp).toLocaleString()}
                    </span>
                </div>
                <div style="font-size: 0.875rem; color: var(--gray-600);">
                    <strong>Hash:</strong> ${tx.hash}<br>
                    <strong>From:</strong> ${Utils.formatAddress(tx.from)}<br>
                    <strong>To:</strong> ${Utils.formatAddress(tx.to)}<br>
                    ${tx.amount ? `<strong>Amount:</strong> ${tx.amount} tokens<br>` : ''}
                    ${tx.gasUsed ? `<strong>Gas Used:</strong> ${tx.gasUsed}<br>` : ''}
                    ${tx.relayer ? `<strong>Relayer:</strong> ${Utils.formatAddress(tx.relayer)}<br>` : ''}
                </div>
            </div>
        `).join('');
        
        historyDiv.innerHTML = historyHTML;
    }

    // Event listeners and initialization
    document.addEventListener('DOMContentLoaded', function() {
        // Set up event listeners for real-time updates
        document.getElementById('userPrivateKey').addEventListener('input', debounce(updateWalletInfo, 1000));
        document.getElementById('relayerPrivateKey').addEventListener('input', debounce(updateWalletInfo, 1000));
        
        // Initialize transaction history
        updateTransactionHistory();
        
        // Update network info periodically
        setInterval(async () => {
            if (AppState.isConnected && AppState.provider) {
                try {
                    const blockNumber = await AppState.provider.getBlockNumber();
                    if (AppState.networkInfo) {
                        AppState.networkInfo.blockNumber = blockNumber;
                        updateNetworkInfo();
                    }
                } catch (error) {
                    console.error('Error updating block number:', error);
                }
            }
        }, 15000); // Update every 15 seconds
    });

    // Utility function for debouncing
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    // Global error handler
    window.addEventListener('error', function(event) {
        console.error('Global error:', event.error);
        Utils.showAlert('adminResults', `‚ùå Unexpected error: ${event.error.message}`, 'error');
    });

    // Expose utilities for debugging
    window.AppState = AppState;
    window.Utils = Utils;
    </script>
</body>
</html>